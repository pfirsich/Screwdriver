Components:
TransformTranslate
    Drag&Drop für alle Objekte
TransformRotate
    Drag&Drop für Rotation (es sollte Marker fürs Zentrum geben)
TransformOffset
    Drag&Drop für Offset + marker fürs Zentrum (Mausbewegungen müssen vorher auch transmorfiert werden)
TransformScale
    siehe oben
Ein Transform-Component mit drei booleans
Sprite
    global gui element - show image borders
TexturedPolygon
    gloabl gui elements - show vertices and edges
    all polygons should have flags for textures (so they can only be edges+vertices (for game logic stuff))
FannedPolygon
FancyPolygon
    Sollten wir als erstes in doof implementieren
Alle Polygons kriegen TextureTransforms! Die auch einfach Drag&drop aber für die Textur sind. Als globales boolean kann man auch die ganze Textur im Hintergrund rendern, wenn man will.
MetadataBoolean
    label - gui label
    name - non-editor name (easier parsable)
    value
MetadataString
MetadataNumber
    min, max
MetadataChoice
    choices = list of id-label-pairs
vllt. MetadataEntity? Um Entites zu verbinden - mit Linien malen? (auch an/aus-bar)
    GUI: Dropdown wäre geil.
    Es geht aber auch mit nem Edit-Mode <-----
    
Edit Modes:
ALT-Selection, muss auch in Edit modes verwendbar sein können (API/effiziente helfer dafür finden)
Edit-Modes sind eigentlich nur Maus-Event-Handler

Multiple selection sollte vom CLI unterstützt sein (alle Funktione sind in der Lage eine Liste von Objekten zu verarbeiten), sodass man, falls wirklich nötig, das CLI benutzen kann um effizient mehrere Entities auf einmal zu bearbeiten, aber man macht sich nicht dir Arbeit das GUI und die edit-modes multiple selection unterstützen zu lassen (besonders, da dies nicht trivial ist und auf versch. arten und weisen gelöst werden kann).

Big three objects (tables): editor, gui, map
map is the whole map-state (saved as-is), gui is everything thats not the editor, editor is the rest

Vermutlich muss man einfach einen Game-Ordner angeben, damit man nicht alles gedoppelt hat und nicht kompliziert kopieren muss. Entweder der Editor ist dann irgendwo im game-ordner? (shiiiiat). Oder man macht io mit dem Lua-io-Modul und wrappt den ganzen love-shit. Man muss dann auch einen kleinen File-Browser frickeln (shiiiiit).
Funktioniert auch nicht, weil directory access nicht ohne Probleme funktioniert, wenn man das Lua io-Modul benutzt.
Dafür wird gebraucht:
    getDirectoryItems
    isDirectory, isFile
    exists
    newFolder
    setWorkingDirectory
    getWorkingDirectory
=======>
Wir wollten LoveFS verwenden. Eventuell kann man in Erwägung ziehen mit dem LuaJIT-FFI die WinAPI-dlls direkt zu laden und die entsprechenden Funktionen direkt aufzurufen, um das erscheinen von einem guten Dutzend cmd-Windows zu vermeiden. In dem Fall ersetzen wie LoveFS durch eine eigene Bibliothek mit der gleichen API. Man sollte sich vorher das Textencoding-Verhalten angucken.


----- entities.lua
entityTypes["weapon_pod"] = {
    label = "Weapon pod", 
    components = { -- errata: this is an array now (integer indices) to preserve order
        transforms = {
            componentType = "Transforms",
            translate = True,
            rotate = True,
            offset = False,
            scale = False,
        },
        sprite = {
            componentType = "Sprite",
            image = "./media/images/weaponPod.png"
        },
        weaponType = {
            componentType = "MetadataChoice",
            label = "Weapon type",
            choices = {
                {"rifle", "Laser rifle"},
                {"shotgun", "XM34 laser shotgun"},
                {"pistol", "Dank ass laser pistol"},
                {"he", "High explosive (laser) grenade"},
                {"exodia", "(laser) frying pan"}
            },
            value = "rifle",
            showInDetails = True
        },
        respawnTime = {
            componentType = "MetadataNumber",
            label = "Respawn time",
            min = 0.0,
            value = 6.0
        },
        shader = {
            componentType = "MetadataString",
            value = "glossystuff",
            hidden = True
        }
    }
}

entity.render =
    for each component:
        component.renderstart()
        
    for each component (reversed)
        component.renderend()

Transforms.setPosition(self.selected, x, y)

Each component specifies GUI-Elements, CLI-functions, edit modes and global settings/gui elements, uniqueness attributes
    uniqueness is important because multiple drawables and definitely multiple transforms make picking nearly impossible
    
    uniqueness: exclude-list which prevents components from being added if other specified components are already presents
    attention: also check the newly created component if it clashed with exisiting ones (in case that some needed excludes are missing in components added before)
    
    OR (better):
    single boolean value ("unique") do determine if a component can only be present once
    boolean value ("pickable") to make sure only one pickable component is present per entity
    
    
local Transforms = class()
function Transforms:init(properties)
    local defaults = {
        translate = True,
        posx = 0, posy = 0,
        
        rotate = True,
        angle = 0,
        
        offset = True,
        offx = 0, offy = 0,
        
        scale = True,
        scalex = 1, scaley = 1
    }
    setProperties(self, properties, defaults)
    
    self.guiElements = {}
    if self.translate then
        table.extend(self.guiElements,{
            {"X-Pos", "Numberwheel", "posx"},
            {"Y-Pos", "Numberwheel", "posy"}
        })
    end
        
    if self.rotate then
        table.insert(self.guiElements, {"Angle", "Numberwheel", "angle"})
    end
    
    if self.offset then 
        table.extend(self.guiElements,{
            {"X-Offset", "Numberwheel", "offx"},
            {"Y-Offset", "Numberwheel", "offy"}
        })
    end
    
    if self.scale then 
        table.extend(self.guiElements,{
            {"X-Scale", "Numberwheel", "scalex"},
            {"Y-Scale", "Numberwheel", "scaley"}
        })
    end
    
    self.unique = True
end

Numberwheel, String, Checkbox, Button, Choice, Color, Texture, Entity?

Transforms.guiElements = {} -- global gui elements

function Transforms.setPosition(entities, x, y) 
    withComponent(entities, "Transforms", function(component)
        component.posx, component.posy = x, y
    end
end

withComponent(entities, "Transforms", function(component) set the values end) = 
    for each entity
        for each component
            if component.componentType = Transforms:
                set the values

oder findComponent(entity, type)
                
components["Transforms"] = Transforms



Transforms.editModes = {
    move = {
        onMouseDown(self, x, y, button)
        onMouseMove(self, x, y)
        onMouseUp(self, x, y, button)
    }
}

Transforms.editModes.move:onMouseDown

pickShapes(entities, x, y)
goes through all the entities' shapes and returns a list of all picked shapes in front to back order

Vertex-Edit-Mode: Drag&Drop auf Vertices bewegt die, Linksklick auf Edges erzeugt neue Vertices, rechtsklick auf Vertices löscht diese


